/**
 * FS
 * Pokemon Showdown - http://pokemonshowdown.com/
 *
 * An abstraction layer around Node's filesystem.
 *
 * Advantages:
 * - write() etc do nothing in unit tests
 * - paths are always relative to PS's base directory
 * - Promises (seriously wtf Node Core what are you thinking)
 * - PS-style API: FS("foo.txt").write("bar") for easier argument order
 * - mkdirp
 *
 * FS is used nearly everywhere, but exceptions include:
 * - crashlogger.js - in case the crash is in here
 * - repl.js - which use Unix sockets out of this file's scope
 * - launch script - happens before modules are loaded
 * - sim/ - intended to be self-contained
 *
 * @author Guangcong Luo <guangcongluo@gmail.com>
 * @license MIT
 */
/// <reference types="node" />
import { ReadStream, WriteStream } from './streams';
export declare class FSPath {
    path: string;
    constructor(path: string);
    parentDir(): FSPath;
    read(options?: AnyObject | string): Promise<string>;
    readSync(options?: AnyObject | string): string;
    readBuffer(options?: AnyObject | string): Promise<Buffer>;
    readBufferSync(options?: AnyObject | string): Buffer;
    exists(): Promise<boolean>;
    existsSync(): boolean;
    readIfExists(): Promise<string>;
    readIfExistsSync(): string;
    write(data: string | Buffer, options?: AnyObject): Promise<void>;
    writeSync(data: string | Buffer, options?: AnyObject): void;
    /**
     * Writes to a new file before renaming to replace an old file. If
     * the process crashes while writing, the old file won't be lost.
     * Does not protect against simultaneous writing; use writeUpdate
     * for that.
     */
    safeWrite(data: string | Buffer, options?: AnyObject): Promise<void>;
    safeWriteSync(data: string | Buffer, options?: AnyObject): void;
    /**
     * Safest way to update a file with in-memory state. Pass a callback
     * that fetches the data to be written. It will write an update,
     * avoiding race conditions. The callback may not necessarily be
     * called, if `writeUpdate` is called many times in a short period.
     *
     * `options.throttle`, if it exists, will make sure updates are not
     * written more than once every `options.throttle` milliseconds.
     *
     * No synchronous version because there's no risk of race conditions
     * with synchronous code; just use `safeWriteSync`.
     */
    writeUpdate(dataFetcher: () => string | Buffer, options?: AnyObject): void;
    writeUpdateNow(dataFetcher: () => string | Buffer, options: AnyObject): void;
    checkNextUpdate(): void;
    finishUpdate(): void;
    append(data: string | Buffer, options?: AnyObject): Promise<void>;
    appendSync(data: string | Buffer, options?: AnyObject): void;
    symlinkTo(target: string): Promise<void>;
    symlinkToSync(target: string): void;
    copyFile(dest: string): Promise<void>;
    rename(target: string): Promise<void>;
    renameSync(target: string): void;
    readdir(): Promise<string[]>;
    readdirSync(): string[];
    createReadStream(): FileReadStream;
    createWriteStream(options?: {}): WriteStream;
    createAppendStream(options?: {}): WriteStream;
    unlinkIfExists(): Promise<void>;
    unlinkIfExistsSync(): void;
    rmdir(recursive?: boolean): Promise<void>;
    rmdirSync(recursive?: boolean): void;
    mkdir(mode?: string | number): Promise<void>;
    mkdirSync(mode?: string | number): void;
    mkdirIfNonexistent(mode?: string | number): Promise<void>;
    mkdirIfNonexistentSync(mode?: string | number): void;
    /**
     * Creates the directory (and any parent directories if necessary).
     * Does not throw if the directory already exists.
     */
    mkdirp(mode?: string | number): Promise<void>;
    /**
     * Creates the directory (and any parent directories if necessary).
     * Does not throw if the directory already exists. Synchronous.
     */
    mkdirpSync(mode?: string | number): void;
    /** Calls the callback if the file is modified. */
    onModify(callback: () => void): void;
    /** Clears callbacks added with onModify(). */
    unwatch(): void;
    isFile(): Promise<boolean>;
    isFileSync(): boolean;
    isDirectory(): Promise<boolean>;
    isDirectorySync(): boolean;
    realpath(): Promise<string>;
    realpathSync(): string;
}
declare class FileReadStream extends ReadStream {
    fd: Promise<number>;
    constructor(file: string);
    _read(size?: number): Promise<void>;
    _destroy(): Promise<void>;
}
declare function getFs(path: string): FSPath;
export declare const FS: typeof getFs & {
    FileReadStream: typeof FileReadStream;
    FSPath: typeof FSPath;
};
export {};
