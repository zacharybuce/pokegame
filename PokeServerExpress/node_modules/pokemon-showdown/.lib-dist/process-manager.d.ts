/**
 * Process Manager
 * Pokemon Showdown - http://pokemonshowdown.com/
 *
 * This file abstract out multiprocess logic involved in several tasks.
 *
 * Child processes can be queried.
 *
 * @license MIT
 */
/// <reference types="node" />
import * as child_process from 'child_process';
import * as cluster from 'cluster';
import * as Streams from './streams';
declare type ChildProcess = child_process.ChildProcess;
declare type Worker = cluster.Worker;
export declare const processManagers: ProcessManager[];
export declare const disabled = false;
export declare function exec(args: string, execOptions?: child_process.ExecOptions): Promise<{
    stderr: string;
    stdout: string;
}>;
export declare function exec(args: [string, ...string[]], execOptions?: child_process.ExecFileOptions): Promise<{
    stderr: string;
    stdout: string;
}>;
declare class SubprocessStream extends Streams.ObjectReadWriteStream<string> {
    process: StreamProcessWrapper;
    taskId: number;
    constructor(process: StreamProcessWrapper, taskId: number);
    _write(message: string): void;
    _writeEnd(): void;
    _destroy(): void;
}
declare class RawSubprocessStream extends Streams.ObjectReadWriteStream<string> {
    process: RawProcessWrapper;
    constructor(process: RawProcessWrapper);
    _write(message: string): void;
}
interface ProcessWrapper {
    getLoad: () => number;
    process: ChildProcess | Worker;
    release: () => Promise<void>;
    getProcess: () => ChildProcess;
}
/** Wraps the process object in the PARENT process. */
export declare class QueryProcessWrapper<T, U> implements ProcessWrapper {
    process: ChildProcess;
    taskId: number;
    pendingTasks: Map<number, (resp: U) => void>;
    messageCallback: ((message: string) => any) | null;
    pendingRelease: Promise<void> | null;
    resolveRelease: (() => void) | null;
    debug?: string;
    constructor(file: string, messageCallback?: (message: string) => any);
    getProcess(): child_process.ChildProcess;
    getLoad(): number;
    query(input: T): Promise<U>;
    release(): Promise<void>;
    destroy(): void;
}
/** Wraps the process object in the PARENT process. */
export declare class StreamProcessWrapper implements ProcessWrapper {
    process: ChildProcess;
    taskId: number;
    activeStreams: Map<number, SubprocessStream>;
    pendingRelease: Promise<void> | null;
    resolveRelease: (() => void) | null;
    debug?: string;
    setDebug(message: string): void;
    messageCallback?: (message: string) => any;
    constructor(file: string, messageCallback?: (message: string) => any);
    getLoad(): number;
    getProcess(): child_process.ChildProcess;
    deleteStream(taskId: number): void;
    createStream(): SubprocessStream;
    release(): Promise<void>;
    destroy(): Promise<void[]> | undefined;
}
/**
 * A container for a RawProcessManager stream. This is usually the
 * RawProcessWrapper, but it can also be a fake RawProcessWrapper if the PM is
 * told to spawn 0 worker processes.
 */
export declare class StreamWorker {
    load: number;
    workerid: number;
    stream: Streams.ObjectReadWriteStream<string>;
    constructor(stream: Streams.ObjectReadWriteStream<string>);
}
/** Wraps the process object in the PARENT process. */
export declare class RawProcessWrapper implements ProcessWrapper, StreamWorker {
    process: ChildProcess & {
        process: undefined;
    } | Worker;
    taskId: number;
    stream: RawSubprocessStream;
    pendingRelease: Promise<void> | null;
    resolveRelease: (() => void) | null;
    debug?: string;
    workerid: number;
    /** Not managed by RawProcessWrapper itself */
    load: number;
    setDebug(message: string): void;
    constructor(file: string, isCluster?: boolean, env?: AnyObject);
    getLoad(): number;
    getProcess(): child_process.ChildProcess;
    release(): Promise<void>;
    destroy(): void;
}
/**
 * A ProcessManager wraps a query function: A function that takes a
 * string and returns a string or Promise<string>.
 */
export declare abstract class ProcessManager<T extends ProcessWrapper = ProcessWrapper> {
    processes: T[];
    releasingProcesses: T[];
    crashedProcesses: T[];
    readonly module: NodeJS.Module;
    readonly filename: string;
    readonly basename: string;
    readonly isParentProcess: boolean;
    crashTime: number;
    crashRespawnCount: number;
    constructor(module: NodeJS.Module);
    acquire(): T | null;
    releaseCrashed(process: T): void;
    unspawn(): Promise<void[]>;
    unspawnOne(process: T | null): Promise<void>;
    spawn(count?: number, force?: boolean): void;
    spawnOne(force?: boolean): T | null;
    respawn(count?: number | null): Promise<void[]>;
    abstract listen(): void;
    abstract createProcess(): T;
    destroyProcess(process: T): void;
    destroy(): Promise<void[]>;
}
export declare class QueryProcessManager<T = string, U = string> extends ProcessManager<QueryProcessWrapper<T, U>> {
    _query: (input: T) => U | Promise<U>;
    messageCallback?: (message: string) => any;
    timeout: number;
    /**
     * @param timeout The number of milliseconds to wait before terminating a query. Defaults to 900000 ms (15 minutes).
     */
    constructor(module: NodeJS.Module, query: (input: T) => U | Promise<U>, timeout?: number, debugCallback?: (message: string) => any);
    query(input: T, process?: QueryProcessWrapper<T, U> | null): Promise<U>;
    queryTemporaryProcess(input: T, force?: boolean): Promise<U>;
    createProcess(): QueryProcessWrapper<T, U>;
    listen(): void;
}
export declare class StreamProcessManager extends ProcessManager<StreamProcessWrapper> {
    activeStreams: Map<string, Streams.ObjectReadWriteStream<string>>;
    _createStream: () => Streams.ObjectReadWriteStream<string>;
    messageCallback?: (message: string) => any;
    constructor(module: NodeJS.Module, createStream: () => Streams.ObjectReadWriteStream<string>, messageCallback?: (message: string) => any);
    createStream(): Streams.ObjectReadWriteStream<string>;
    createProcess(): StreamProcessWrapper;
    pipeStream(taskId: string, stream: Streams.ObjectReadStream<string>): Promise<void>;
    listen(): void;
}
export declare class RawProcessManager extends ProcessManager<RawProcessWrapper> {
    /** full list of processes - parent process only */
    workers: StreamWorker[];
    /** if spawning 0 worker processes, the worker is instead stored here in the parent process */
    masterWorker: StreamWorker | null;
    /** stream used only in the child process */
    activeStream: Streams.ObjectReadWriteStream<string> | null;
    isCluster: boolean;
    spawnSubscription: ((worker: StreamWorker) => void) | null;
    unspawnSubscription: ((worker: StreamWorker) => void) | null;
    _setupChild: () => Streams.ObjectReadWriteStream<string>;
    /** worker ID of cluster worker - cluster child process only (0 otherwise) */
    readonly workerid: number;
    env: AnyObject | undefined;
    constructor(options: {
        module: NodeJS.Module;
        setupChild: () => Streams.ObjectReadWriteStream<string>;
        isCluster?: boolean;
        env?: AnyObject;
    });
    subscribeSpawn(callback: (worker: StreamWorker) => void): void;
    subscribeUnspawn(callback: (worker: StreamWorker) => void): void;
    spawn(count?: number): void;
    createProcess(): RawProcessWrapper;
    destroyProcess(process: RawProcessWrapper): void;
    pipeStream(stream: Streams.ObjectReadStream<string>): Promise<void>;
    listen(): void;
}
export {};
